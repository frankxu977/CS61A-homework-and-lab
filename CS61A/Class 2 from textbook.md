
### 1.4 设计函数 - 核心总结

本章的核心思想是：**函数是抽象的工具**，好的函数设计能提升代码的可读性、可维护性和减少错误。

#### 优秀函数的设计原则

1.  **单一职责原则**
    *   每个函数只做一件事，并且这件事可以用一个简短的名称和一行文本清晰描述。
    *   如果一个函数按顺序执行多个任务，应该将其拆分成多个函数。

2.  **DRY 原则**
    *   **不要重复你自己**。如果发现自己在复制粘贴代码块，这就是一个使用函数抽象的机会。
    *   将重复的逻辑实现一次，命名，然后多次应用。

3.  **通用性原则**
    *   函数应该尽可能定义得通用。例如，Python 没有单独的 `square` 函数，因为它只是通用 `pow` 函数的一个特例。

#### 提升函数设计的 Python 特性

1.  **文档**
    *   **文档字符串**: 使用三引号 `"""` 包裹的函数说明。第一行简要描述函数功能，后续行可描述参数和行为。
        *   **作用**： 供 `help()` 函数调用，是代码写给人的说明书。
        *   **准则**： 除了最简单的函数，都应编写文档字符串。
    *   **注释**: 以 `#` 开头，用于解释代码行或块背后的逻辑。
        *   **作用**： 仅供人类阅读，解释“为什么”这么做，解释复杂的逻辑。解释“做什么”是文档字符串的责任。

2.  **默认参数值**
    *   **目的**： 让通用函数更易用，避免调用时需要提供所有参数，提高代码可读性。
    *   **语法**： 在函数定义 `def` 语句中，使用 `参数名=默认值` 的形式。
    *   **工作方式**： 调用函数时，如果某个有默认值的参数未被提供，则使用其默认值。
    *   **使用准则**：
        *   函数体中用到的多数数据值应作为命名参数的默认值，这样便于调用者检查和覆盖。
        *   永恒不变的值（如玻尔兹曼常数 `k`）可以定义在函数体内或全局框架中。



好的，这是对 **1.5 控制** 章节的总结，并保留了重要的英文术语和概念：

### 1.5 控制 - 核心总结

本章的核心思想是：**控制语句**通过基于比较结果来改变程序的执行流程，从而极大地增强了我们定义函数的能力。

#### 1.5.1 语句

*   **语句 vs. 表达式**:
    *   **表达式**: 用于**计算**一个值。
    *   **语句**: 用于**执行**一个动作，改变解释器的状态。它们本身没有值。
    *   我们已经接触的语句: **assignment**, **def**, **return**。
    *   一个常见的错误是函数体内只有表达式而没有 `return`，导致结果被丢弃。
        ```python
        def square(x):
            mul(x, x)  # Watch out! This call doesn't return a value.
        ```

#### 1.5.2 复合语句

*   **简单语句**: 单行，不以冒号结尾。
*   **复合语句**: 由其他语句组成，跨越多行。以一个以冒号结尾的**头部**开始，后跟一个缩进的**语句组**。
    *   **结构**: `<header>: <suite>`
    *   例如：`def` 语句就是一个复合语句。
*   执行规则：按顺序执行，除非控制流被重定向。

#### 1.5.3 定义函数 II：局部赋值

*   函数体可以包含多个语句，而不仅仅是一个 `return` 表达式。
*   函数在**局部环境**中执行，该环境始于为该函数调用创建的**局部帧**。
*   **局部赋值** (`=`) 在函数的局部帧中绑定名字，不会影响**全局帧**。这是实现**模块化编程**的关键。
*   局部赋值通过为中间量命名，可以澄清复杂表达式的含义。

#### 1.5.4 条件语句

*   **条件语句** 让我们能够根据比较结果执行不同的代码块。
*   **语法结构**:
    ```python
    if <expression>:
        <suite>
    elif <expression>:
        <suite>
    else:
        <suite>
    ```
*   **执行流程**: 按顺序评估每个子句的头部表达式。如果为 **true value**，则执行其对应的语句组，并跳过剩余子句。如果所有 `if`/`elif` 都为 **false value**，则执行 `else` 子句。
*   **布尔上下文**: 在条件语句头部中的表达式处于布尔上下文中，它们的真值决定了控制流。
*   **布尔值**: `True` 和 `False`。比较操作符 (`>`, `<`, `>=`, `<=`, `==`, `!=`) 返回布尔值。
    *   **注意**: `=` 是赋值，`==` 是相等比较。
*   **布尔运算符**:
    *   `and`: 短路求值，如果左边为 false value，则直接返回左边的值，否则返回右边的值。
    *   `or`: 短路求值，如果左边为 true value，则直接返回左边的值，否则返回右边的值。
    *   `not`: 返回表达式的相反布尔值。

#### 1.5.5 迭代

*   **迭代控制结构** 允许我们重复执行语句。
*   **`while` 语句**:
    ```python
    while <expression>:
        <suite>
    ```
*   **执行流程**:
    1.  评估头部表达式。
    2.  如果为 true value，执行语句组，然后**返回步骤1**。
*   **关键点**: 语句组内部必须改变某些状态，否则可能导致**无限循环**。
*   **并行赋值**: `pred, curr = curr, pred + curr`。等号右边的所有表达式会先被计算，然后再进行左边的绑定。

#### 1.5.6 测试

*   **测试** 是验证函数行为是否符合预期的系统性方法。
*   **`assert` 语句**:
    ```python
    assert <expression>, 'Error message'
    ```
    *   如果表达式为 true，无事发生。
    *   如果表达式为 false，抛出 **`AssertionError`** 并停止执行。
*   **Doctests**: 一种将简单测试直接写入函数**文档字符串**的便捷方法。
    *   **格式**: 在文档字符串中，使用 `>>>` 开头写入函数调用，下一行写期望的输出。
    *   **运行方式**:
        *   在解释器中: `from doctest import testmod` / `testmod()`
        *   在命令行: `python3 -m doctest <python_source_file>`
*   **单元测试**: 对单个函数进行的测试。
*   **最佳实践**: 在实现函数后（甚至之前）立即编写并运行测试。
